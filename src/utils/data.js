/*
 * Data utilities
 *
 * Pure functions for manipulating and validating transactions and other
 * domain objects. These functions are designed to be stateless and free
 * from side effects so they can be reused and tested in isolation. Callers
 * must provide any required context (such as the list of cards) as
 * parameters rather than relying on the existence of global variables.
 */

import { todayISO, postDateForCard } from './date.js';

/**
 * Ensure that each transaction in the provided list has the required
 * attributes. Missing fields will be inferred when possible:
 *   - opDate: defaults to today or derived from a timestamp (ts)
 *   - postDate: computed based on card rules
 *   - planned: true if the operation date is in the future
 *
 * @param {Array<object>} list array of transactions
 * @param {Array<object>} cards list of available cards for computing postDate
 * @returns {{ list: Array<object>, changed: boolean }} sanitized list and whether any modifications were made
 */
export function sanitizeTransactions(list, cards = []) {
  let changed = false;
  const out = (list || []).map((t) => {
    if (!t) return t;
    const nt = { ...t };
    // opDate: operation date. Use existing if present; derive from timestamp or default to today
    if (!nt.opDate) {
      if (nt.ts) {
        try {
          nt.opDate = new Date(nt.ts).toISOString().slice(0, 10);
        } catch {
          nt.opDate = todayISO();
        }
      } else {
        nt.opDate = todayISO();
      }
      changed = true;
    }
    // postDate: posting (invoice) date. Compute from card rules
    if (!nt.postDate) {
      const method = nt.method || 'Dinheiro';
      try {
        nt.postDate = postDateForCard(nt.opDate, method, cards);
      } catch {
        nt.postDate = nt.opDate;
      }
      changed = true;
    }
    // planned: whether this transaction is scheduled in the future
    if (typeof nt.planned === 'undefined' && nt.opDate) {
      nt.planned = nt.opDate > todayISO();
      changed = true;
    }
    return nt;
  });
  return { list: out, changed };
}

/**
 * Validate the shape of a transaction object. Ensures that required fields
 * are present and have the expected types.
 *
 * @param {object} tx transaction object to validate
 * @returns {{ isValid: boolean, errors: string[] }} result
 */
export function validateTransaction(tx) {
  const errors = [];
  if (!tx) {
    errors.push('Transaction object is required');
    return { isValid: false, errors };
  }
  if (!tx.desc || typeof tx.desc !== 'string' || tx.desc.trim() === '') {
    errors.push('Description is required');
  }
  if (typeof tx.val !== 'number' || Number.isNaN(tx.val)) {
    errors.push('Value must be a valid number');
  }
  if (!tx.opDate || !/^\d{4}-\d{2}-\d{2}$/.test(tx.opDate)) {
    errors.push('Operation date must be in YYYY-MM-DD format');
  }
  if (!tx.method || typeof tx.method !== 'string') {
    errors.push('Payment method is required');
  }
  return { isValid: errors.length === 0, errors };
}

/**
 * Determine whether a transaction represents a detached occurrence from a
 * recurrence series. A detached occurrence is generated by editing or
 * deleting a single occurrence of a recurring transaction.
 *
 * @param {object} tx transaction object
 * @returns {boolean} true if the transaction is detached
 */
export function isDetachedOccurrence(tx) {
  return !!(tx && tx.parentId && !tx.recurrence);
}

/**
 * Generate a reasonably unique identifier for a transaction or other
 * entity. Uses a combination of the current timestamp and random data.
 *
 * @returns {string} unique identifier
 */
export function generateId() {
  return Date.now().toString(36) + Math.random().toString(36).substring(2);
}

/**
 * Deep clone a value. Supports primitives, arrays and plain objects. Does not
 * correctly handle circular references or special object types (Map, Set,
 * Date, etc.) beyond shallow copying. Use with care.
 *
 * @param {any} obj value to clone
 * @returns {any} cloned value
 */
export function deepClone(obj) {
  if (obj === null || typeof obj !== 'object') return obj;
  if (Array.isArray(obj)) return obj.map((v) => deepClone(v));
  const cloned = {};
  for (const key of Object.keys(obj)) {
    cloned[key] = deepClone(obj[key]);
  }
  return cloned;
}

/**
 * Sort transactions by descending date. Uses opDate or postDate to compare.
 *
 * @param {Array<object>} transactions list of transactions
 * @returns {Array<object>} sorted transactions (new array)
 */
export function sortTransactionsByDate(transactions) {
  return [...(transactions || [])].sort((a, b) => {
    const dateA = a.opDate || a.postDate || '';
    const dateB = b.opDate || b.postDate || '';
    return dateB.localeCompare(dateA);
  });
}

/**
 * Filter transactions to those whose dates fall within a given range.
 *
 * @param {Array<object>} transactions list of transactions
 * @param {string} startDate inclusive start date (YYYY‑MM‑DD)
 * @param {string} endDate inclusive end date (YYYY‑MM‑DD)
 * @returns {Array<object>} filtered list
 */
export function filterTransactionsByDateRange(transactions, startDate, endDate) {
  return (transactions || []).filter((tx) => {
    const txDate = tx.opDate || tx.postDate;
    return txDate && txDate >= startDate && txDate <= endDate;
  });
}

/**
 * Compute the sum of a property across a list of transactions. The
 * transaction’s `val` field is assumed to be a numeric value representing
 * either an expense (negative) or income (positive).
 *
 * @param {Array<object>} transactions list of transactions
   * @returns {number} sum of values
 */
export function calculateTotal(transactions) {
  return (transactions || []).reduce((sum, tx) => {
    return sum + (tx.val || 0);
  }, 0);
}

/**
 * Check whether an element is contained within a scrollable modal. Useful
 * for determining which scrolling container to operate on when focusing
 * form fields.
 *
 * @param {HTMLElement} el element to test
 * @returns {boolean} true if the element is inside a scrollable modal
 */
export function isInScrollableModal(el) {
  if (!el) return false;
  let node = el;
  while (node && node !== document.body) {
    const computed = window.getComputedStyle(node);
    const overflowY = computed.overflowY;
    const hasScroll = node.scrollHeight > node.clientHeight;
    if ((overflowY === 'auto' || overflowY === 'scroll') && hasScroll) {
      const modal = node.closest('.modal');
      if (modal) return true;
    }
    node = node.parentElement;
  }
  return false;
}